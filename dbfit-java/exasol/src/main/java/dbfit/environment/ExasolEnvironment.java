package dbfit.environment;

import dbfit.annotations.DatabaseEnvironment;
import dbfit.api.AbstractDbEnvironment;
import dbfit.util.DbParameterAccessor;
import dbfit.util.Direction;
import dbfit.util.NameNormaliser;
import dbfit.util.ParamDescriptor;
import dbfit.util.Log;

import javax.sql.RowSet;

import java.math.BigDecimal;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.*;
import java.util.regex.Pattern;
import static org.apache.commons.lang3.ObjectUtils.defaultIfNull;

/*
 * @author: Bodo Huesemann (bhuesemann@informationsfabrik.de)
 *
 */
@DatabaseEnvironment(name = "Exasol", driver = "com.exasol.jdbc.EXADriver")
public class ExasolEnvironment extends AbstractDbEnvironment {
    public ExasolEnvironment(String driverClassName) {
        super(driverClassName);
    }

    protected String getConnectionString(String dataSource) {
        return "jdbc:exa:" + dataSource;
    }

    protected String getConnectionString(String dataSource, String database) {
        return "jdbc:exa:" + dataSource + ";schema=" + database;
    }

    // named parameters are prefixed with @
    private static String paramNamePattern = "@([A-Za-z0-9_]+)";
    private static Pattern paramsNames = Pattern.compile(paramNamePattern);

    public Pattern getParameterPattern() {
        return paramsNames;
    }

    // prepareStatement(String sql, int autoGeneratedKeys)
    public PreparedStatement buildInsertPreparedStatement(String tableName,
            DbParameterAccessor[] accessors) throws SQLException {
        String insertCommand = buildInsertCommand(tableName, accessors);
        return getConnection().prepareStatement(insertCommand, Statement.NO_GENERATED_KEYS);
    }

    // convert named parameter into positional parameter
    // ToDo: check if this is necessary for Exasol
    // protected String parseCommandText(String commandText) {
    // commandText = commandText.replaceAll(paramNamePattern, "?");
    // return super.parseCommandText(commandText);
    // }

    public Map<String, DbParameterAccessor> getAllColumns(String tableOrViewName)
            throws SQLException {
        String[] qualifiers = NameNormaliser.normaliseName(tableOrViewName).split("\\.");
        String qry = " SELECT column_name, column_type datatype FROM exa_user_columns edc WHERE ";

        if (qualifiers.length == 2) {
            qry += " lower(column_schema) = lower(?) and lower(column_table) = lower(?) ";
        } else {
            qry += " column_schema = COALESCE (CURRENT_SCHEMA, column_schema) and lower(column_table) = lower(?) ";
        }
        qry += " order by column_ordinal_position";
        return readColumnsFromDb(qualifiers, qry);
    }

    private Map<String, DbParameterAccessor> readColumnsFromDb(String[] parametersForColumnQuery,
            String query) throws SQLException {
        try (PreparedStatement dc = currentConnection.prepareStatement(query)) {
            for (int i = 0; i < parametersForColumnQuery.length; i++) {
                dc.setString(i + 1, NameNormaliser.normaliseName(parametersForColumnQuery[i]));
            }
            ResultSet rs = dc.executeQuery();
            Map<String, DbParameterAccessor> columns = new HashMap<String, DbParameterAccessor>();
            int position = 0;
            while (rs.next()) {
                String columnName = defaultIfNull(rs.getString(1), "");
                String dataType = rs.getString(2);
                DbParameterAccessor dbp = createDbParameterAccessor(columnName, Direction.INPUT,
                        getSqlType(dataType), getJavaClass(dataType), position++);
                columns.put(NameNormaliser.normaliseName(columnName), dbp);
            }
            rs.close();
            return columns;
        }
    }

    // List interface has sequential search, so using list instead of array to map types
    // see https://docs.exasol.com/sql_references/data_types/datatypedetails.htm
    // https://docs.exasol.com/sql_references/data_types/datatypealiases.htm
    // Heads up: https://www.exasol.com/support/browse/EXASOL-1922
    private static List<String> stringTypes = Arrays.asList(new String[] {"VARCHAR", "CHAR",
            "NCLOB", "CLOB", "GEOMETRY", "HASHTYPE", "NCHAR", "VARCHAR2", "LONG"});
    private static List<String> intTypes = Arrays.asList(new String[] {"INTEGER", "INT"});
    private static List<String> longTypes = Arrays.asList(new String[] {"BIGINT"});
    private static List<String> shortTypes = Arrays.asList(new String[] {"SMALLINT"});
    private static List<String> floatTypes = Arrays.asList(new String[] {"FLOAT"});
    private static List<String> doubleTypes =
            Arrays.asList(new String[] {"DOUBLE PRECISION", "REAL", "DOUBLE"});
    private static List<String> decimalTypes = Arrays.asList(new String[] {"DECIMAL"});
    private static List<String> dateTypes = Arrays.asList(new String[] {"DATE"});
    private static List<String> timestampTypes =
            Arrays.asList(new String[] {"TIMESTAMP", "TIMESTAMP WITH LOCAL TIME ZONE"});
    private static List<String> timeTypes = Arrays.asList(new String[] {});
    private static List<String> refCursorTypes = Arrays.asList(new String[] {});
    private static List<String> booleanTypes = Arrays.asList(new String[] {"BOOLEAN", "BOOL"});
    private static List<String> varBinaryTypes = Arrays.asList(new String[] {});
    private static List<String> blobTypes = Arrays.asList(new String[] {});
    private static List<String> clobTypes = Arrays.asList(new String[] {});

    private static String normaliseTypeName(String dataType) {
        if (dataType.indexOf("(") <= 0) {
            dataType = dataType.toUpperCase().trim();
        } else {
            dataType = dataType.toUpperCase().trim().substring(0, dataType.indexOf("("));
        }
        return dataType;
    }

    private static int getSqlType(String dataType) {
        dataType = normaliseTypeName(dataType);

        if (stringTypes.contains(dataType))
            return java.sql.Types.VARCHAR;
        if (decimalTypes.contains(dataType))
            return java.sql.Types.NUMERIC;
        if (intTypes.contains(dataType))
            return java.sql.Types.INTEGER;
        if (floatTypes.contains(dataType))
            return java.sql.Types.FLOAT;
        if (doubleTypes.contains(dataType))
            return java.sql.Types.DOUBLE;
        if (longTypes.contains(dataType))
            return java.sql.Types.BIGINT;
        if (timestampTypes.contains(dataType))
            return java.sql.Types.TIMESTAMP;
        if (dateTypes.contains(dataType))
            return java.sql.Types.DATE;
        if (dateTypes.contains(dataType))
            return java.sql.Types.TIME;
        if (refCursorTypes.contains(dataType))
            return java.sql.Types.REF;
        if (booleanTypes.contains(dataType))
            return java.sql.Types.BOOLEAN;
        if (clobTypes.contains(dataType))
            return java.sql.Types.CLOB;
        if (blobTypes.contains(dataType))
            return java.sql.Types.BLOB;
        if (varBinaryTypes.contains(dataType))
            return java.sql.Types.VARBINARY;
        if (shortTypes.contains(dataType))
            return java.sql.Types.SMALLINT;


        throw new UnsupportedOperationException("Type " + dataType + " is not supported");
    }

    @SuppressWarnings({"unchecked", "rawtypes"})
    public Class getJavaClass(String dataType) {
        dataType = normaliseTypeName(dataType);
        if (stringTypes.contains(dataType))
            return String.class;
        if (decimalTypes.contains(dataType))
            return BigDecimal.class;
        if (intTypes.contains(dataType))
            return Integer.class;
        if (floatTypes.contains(dataType))
            return Float.class;
        if (dateTypes.contains(dataType))
            return java.sql.Date.class;
        if (refCursorTypes.contains(dataType))
            return RowSet.class;
        if (doubleTypes.contains(dataType))
            return Double.class;
        if (longTypes.contains(dataType))
            return Long.class;
        if (timeTypes.contains(dataType))
            return java.sql.Time.class;
        if (timestampTypes.contains(dataType))
            return java.sql.Timestamp.class;
        if (booleanTypes.contains(dataType))
            return Boolean.class;
        if (clobTypes.contains(dataType))
            return String.class;
        if (blobTypes.contains(dataType))
            return java.sql.Blob.class;
        if (varBinaryTypes.contains(dataType))
            return java.sql.Blob.class;
        if (shortTypes.contains(dataType))
            return Short.class;
        throw new UnsupportedOperationException("Type " + dataType + " is not supported");
    }

    public Map<String, DbParameterAccessor> getAllProcedureParameters(String procName)
            throws SQLException {

        String[] qualifiers = NameNormaliser.normaliseName(procName).split("\\.");
        String qry =
                " SELECT script_type, script_language, script_input_type, script_result_type, script_text "
                        + " FROM exa_user_scripts WHERE ";

        if (qualifiers.length == 2) {
            qry += " lower(script_schema) = lower(?) and lower(script_name) = lower(?) ";
        } else {
            qry += " script_schema=COALESCE(CURRENT_SCHEMA, script_schema) AND lower(script_name) = lower(?) ";
        }

        String scriptType;
        String scriptLang;
        String scriptInputType;
        String scriptResultType;
        String scriptText;

        try (PreparedStatement dc = currentConnection.prepareStatement(qry)) {
            for (int i = 0; i < qualifiers.length; i++) {
                dc.setString(i + 1, NameNormaliser.normaliseName(qualifiers[i]));
            }
            ResultSet rs = dc.executeQuery();
            if (!rs.next()) {
                throw new SQLException("Unknown procedure " + procName);
            }

            scriptType = rs.getString(1);
            scriptLang = rs.getString(2);
            scriptInputType = rs.getString(3);
            scriptResultType = rs.getString(4);
            scriptText = defaultIfNull(rs.getString(5), "");
            rs.close();
        }

        ExasolSqlProcedureParametersParser parser = new ExasolSqlProcedureParametersParser();
        Map<String, DbParameterAccessor> allParams = new HashMap<String, DbParameterAccessor>();

        int position = 0;
        for (ParamDescriptor pd : parser.parseParameters(scriptText)) {
            DbParameterAccessor dbp = createDbParameterAccessor(pd.name, pd.direction,
                    getSqlType(pd.type), getJavaClass(pd.type), position++);
            allParams.put(NameNormaliser.normaliseName(pd.name), dbp);
        }

        if ("UDF".equals(scriptType)) {
            ParamDescriptor rd = parser.parseReturnType(scriptInputType);
            allParams.put("", createDbParameterAccessor("", Direction.RETURN_VALUE,
                    getSqlType(rd.type), getJavaClass(rd.type), -1));
        }

        return allParams;
    }

    public String buildInsertCommand(String tableName, DbParameterAccessor[] accessors) {
        StringBuilder sb = new StringBuilder("insert into ");
        sb.append(tableName).append("(");
        String comma = "";
        String retComma = "";

        StringBuilder values = new StringBuilder();
        StringBuilder retNames = new StringBuilder();
        StringBuilder retValues = new StringBuilder();

        for (DbParameterAccessor accessor : accessors) {
            if (accessor.hasDirection(Direction.INPUT)) {
                sb.append(comma);
                values.append(comma);
                sb.append(accessor.getName());
                values.append("?");
                comma = ",";
            } else {
                retNames.append(retComma);
                retValues.append(retComma);
                retNames.append(accessor.getName());
                retValues.append("?");
                retComma = ",";
            }
        }
        sb.append(") values (");
        sb.append(values);
        sb.append(")");
        Log.log("built " + sb.toString());
        return sb.toString();
    }
}
